<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用cloudflare Worker代理telegram bot api</title>
    <link href="/202301/%E4%BD%BF%E7%94%A8cloudflare-Worker%E4%BB%A3%E7%90%86telegram-bot-api/"/>
    <url>/202301/%E4%BD%BF%E7%94%A8cloudflare-Worker%E4%BB%A3%E7%90%86telegram-bot-api/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>众所周知，Telegram不在中国提供服务，以至于Telegram bot api无法使用。并且我们要在程序中使用Telegram bot api时，代理程序不好写进去，一般都会使用系统代理或干脆直接tun模式来强制程序代理。这时不妨换个思路，使用cloudflare代理telegram bot api。（也可以在vps上使用nginx反代。但白嫖cloudflare更爽，要实现真正完全白嫖，还可以在 <strong><code>eu.org</code></strong> 白嫖一个域名，这里不细说</p><h1 id="创建Workers反代项目"><a href="#创建Workers反代项目" class="headerlink" title="创建Workers反代项目"></a>创建Workers反代项目</h1><p>登录cloudflare，点击workers<br><img src="https://s2.loli.net/2023/02/13/qOy3flN5eoUECJp.webp" title="cloudflare workers"><br>点击创建服务<br><img src="https://s2.loli.net/2023/02/13/AcPCHTvSBoUJmbI.webp" title="创建"><br>名称随意填写，但是下面需要选择 <strong>HTTP路由器</strong><br><img src="https://s2.loli.net/2023/02/13/UROmDoHbqtAY1NS.webp"><br>创建完成后，点击刚创建的Worker，再点击快速编辑<br><img src="https://s2.loli.net/2023/02/13/MVrma3lU59bySeO.webp"><br>删除红框处所有的代码，填入以下代码<br><img src="https://s2.loli.net/2023/02/13/ozEXLUP9BfxC4Ha.webp"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Helper functions to check if the request uses</span><br><span class="hljs-comment"> * corresponding method.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Method</span> = (<span class="hljs-params">method</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> req.<span class="hljs-property">method</span>.<span class="hljs-title function_">toLowerCase</span>() === method.<span class="hljs-title function_">toLowerCase</span>();<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Get</span> = <span class="hljs-title class_">Method</span>(<span class="hljs-string">&#x27;get&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Post</span> = <span class="hljs-title class_">Method</span>(<span class="hljs-string">&#x27;post&#x27;</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Path</span> = (<span class="hljs-params">regExp</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(req.<span class="hljs-property">url</span>);<br><span class="hljs-keyword">const</span> path = url.<span class="hljs-property">pathname</span>;<br><span class="hljs-keyword">return</span> path.<span class="hljs-title function_">match</span>(regExp) &amp;&amp; path.<span class="hljs-title function_">match</span>(regExp)[<span class="hljs-number">0</span>] === path;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The regex to get the bot_token and api_method from request URL</span><br><span class="hljs-comment"> * as the first and second backreference respectively.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">URL_PATH_REGEX</span> = <span class="hljs-regexp">/^\/bot(?&lt;bot_token&gt;[^/]+)\/(?&lt;api_method&gt;[a-z]+)/i</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Router handles the logic of what handler is matched given conditions</span><br><span class="hljs-comment"> * for each request</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span> &#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span> = [];<br>&#125;<br><br><span class="hljs-title function_">handle</span>(<span class="hljs-params">conditions, handler</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>.<span class="hljs-title function_">push</span>(&#123;<br>conditions,<br>handler,<br>&#125;);<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br><br><span class="hljs-title function_">get</span>(<span class="hljs-params">url, handler</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handle</span>([<span class="hljs-title class_">Get</span>, <span class="hljs-title class_">Path</span>(url)], handler);<br>&#125;<br><br><span class="hljs-title function_">post</span>(<span class="hljs-params">url, handler</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handle</span>([<span class="hljs-title class_">Post</span>, <span class="hljs-title class_">Path</span>(url)], handler);<br>&#125;<br><br><span class="hljs-title function_">all</span>(<span class="hljs-params">handler</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handler</span>([], handler);<br>&#125;<br><br><span class="hljs-title function_">route</span>(<span class="hljs-params">req</span>) &#123;<br><span class="hljs-keyword">const</span> route = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resolve</span>(req);<br><br><span class="hljs-keyword">if</span> (route) &#123;<br><span class="hljs-keyword">return</span> route.<span class="hljs-title function_">handler</span>(req);<br>&#125;<br><br><span class="hljs-keyword">const</span> description = <span class="hljs-string">&#x27;No matching route found&#x27;</span>;<br><span class="hljs-keyword">const</span> error_code = <span class="hljs-number">404</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br><span class="hljs-attr">ok</span>: <span class="hljs-literal">false</span>,<br>error_code,<br>description,<br>&#125;),<br>&#123;<br><span class="hljs-attr">status</span>: error_code,<br><span class="hljs-attr">statusText</span>: description,<br><span class="hljs-attr">headers</span>: &#123;<br><span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>&#125;,<br>&#125;<br>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * It returns the matching route that returns true</span><br><span class="hljs-comment"> * for all the conditions if any.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">resolve</span>(<span class="hljs-params">req</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (!r.<span class="hljs-property">conditions</span> || (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(r) &amp;&amp; !r.<span class="hljs-property">conditions</span>.<span class="hljs-property">length</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> r.<span class="hljs-property">conditions</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br><span class="hljs-keyword">return</span> r.<span class="hljs-title function_">conditions</span>(req);<br>&#125;<br><br><span class="hljs-keyword">return</span> r.<span class="hljs-property">conditions</span>.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> <span class="hljs-title function_">c</span>(req));<br>&#125;);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sends a POST request with JSON data to Telegram Bot API</span><br><span class="hljs-comment"> * and reads in the response body.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Request</span>&#125; request the incoming request</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">request</span>) &#123;<br><span class="hljs-comment">// Extract the URl method from the request.</span><br><span class="hljs-keyword">const</span> &#123; url, ..._request &#125; = request;<br><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">pathname</span>: path, search &#125; = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(url);<br><br><span class="hljs-comment">// Leave the first match as we are interested only in backreferences.</span><br><span class="hljs-keyword">const</span> &#123; bot_token, api_method &#125; = path.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">URL_PATH_REGEX</span>).<span class="hljs-property">groups</span>;<br><br><span class="hljs-comment">// Build the URL</span><br><span class="hljs-keyword">const</span> api_url = <span class="hljs-string">&#x27;https://api.telegram.org/bot&#x27;</span> + bot_token + <span class="hljs-string">&#x27;/&#x27;</span> + api_method + search;<br><br><span class="hljs-comment">// Get the response from API.</span><br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(api_url, _request);<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">text</span>();<br><br><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(result, _request);<br><br>res.<span class="hljs-property">headers</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Handles the incoming request.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Request</span>&#125; request the incoming request.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">request</span>) &#123;<br><span class="hljs-keyword">const</span> r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();<br>r.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">URL_PATH_REGEX</span>, <span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> <span class="hljs-title function_">handler</span>(req));<br>r.<span class="hljs-title function_">post</span>(<span class="hljs-variable constant_">URL_PATH_REGEX</span>, <span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> <span class="hljs-title function_">handler</span>(req));<br><br><span class="hljs-keyword">const</span> resp = <span class="hljs-keyword">await</span> r.<span class="hljs-title function_">route</span>(request);<br><span class="hljs-keyword">return</span> resp;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Hook into the fetch event.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>event.<span class="hljs-title function_">respondWith</span>(<span class="hljs-title function_">handleRequest</span>(event.<span class="hljs-property">request</span>));<br>&#125;);<br></code></pre></td></tr></table></figure><p>然后保存并部署，之后可以在触发器中添加自己的域名<br><img src="https://s2.loli.net/2023/02/13/Wkbm8F4ifGn3Pd1.webp"></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>之后，只需要把telegram api地址替换成 <strong><code>https://yourdomain.xxx</code></strong> 即可</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>CDN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>CDN</tag>
      
      <tag>Telegram</tag>
      
      <tag>Cloudflare</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RSS介绍+为你的Hexo博客添加RSS</title>
    <link href="/202301/RSS%E4%BB%8B%E7%BB%8D-%E4%B8%BA%E4%BD%A0%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS/"/>
    <url>/202301/RSS%E4%BB%8B%E7%BB%8D-%E4%B8%BA%E4%BD%A0%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS/</url>
    
    <content type="html"><![CDATA[<h1 id="RSS介绍"><a href="#RSS介绍" class="headerlink" title="RSS介绍"></a>RSS介绍</h1><p>暂时略~~~</p><h1 id="为Hexo添加RSS"><a href="#为Hexo添加RSS" class="headerlink" title="为Hexo添加RSS"></a>为Hexo添加RSS</h1><h2 id="hexo-generator-feed插件"><a href="#hexo-generator-feed插件" class="headerlink" title="hexo-generator-feed插件"></a>hexo-generator-feed插件</h2><p>在Hexo目录下使用如下指令安装RSS生成工具， <strong><code>hexo-generator-feed</code></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-generator-feed<br></code></pre></td></tr></table></figure><p>在 <strong><code>_config.yml</code></strong> 文件添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feed:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">atom</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">atom.xml</span><br>    <span class="hljs-attr">limit:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">hub:</span><br>    <span class="hljs-attr">content:</span><br>    <span class="hljs-attr">content_limit:</span><br>    <span class="hljs-attr">content_limit_delim:</span> <span class="hljs-string">&#x27; &#x27;</span><br></code></pre></td></tr></table></figure><p>参数的含义：<br><code>type</code>: RSS的类型(<code>atom</code>&#x2F;<code>rss2</code>)<br><code>path</code>: 文件路径,默认是<code>atom.xml</code>&#x2F;<code>rss2.xml</code><br><code>limit</code>: 展示文章的数量,使用<code>0</code>或则<code>false</code>代表展示全部<br><code>hub</code>:<br><code>content</code>: 在RSS文件中是否包含内容 ,有3个值 <code>true/false</code>默认不填为<code>false</code><br><code>content_limit</code>: 指定内容的长度作为摘要,仅仅在上面content设置为false和没有自定义的描述出现<br><code>content_limit_delim</code>: 上面截取描述的分隔符,截取内容是以指定的这个分隔符作为截取结束的标志.在达到规定的内容长度之前最后出现的这个分隔符之前的内容,，防止从中间截断.<br>之后使用 <code>http(s)://你的博客地址/atom.xml #http(s)://你的博客地址/rss2.xml</code> 订阅</p><h2 id="主题自带（以Next主题为例）"><a href="#主题自带（以Next主题为例）" class="headerlink" title="主题自带（以Next主题为例）"></a>主题自带（以Next主题为例）</h2><p>在 <strong><code>Next</code></strong> 主题的 <strong><code>_config.yml</code></strong> 文件中有个 <strong>rss</strong> 的配置，直接设置为 <strong>true</strong><br>其他主题可在使用手册查看是否支持，如何开启</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Blog</category>
      
      <category>RSS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>Blog</tag>
      
      <tag>RSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Grub更改排序(不是默认启动项)</title>
    <link href="/202301/Grub%E6%9B%B4%E6%94%B9%E6%8E%92%E5%BA%8F-%E4%B8%8D%E6%98%AF%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E9%A1%B9/"/>
    <url>/202301/Grub%E6%9B%B4%E6%94%B9%E6%8E%92%E5%BA%8F-%E4%B8%8D%E6%98%AF%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于主要使用Windows，但按照常规方法设置grub默认启动项后，会(强)十(迫)分(症)影(受)响(不)美(了)观，所以，这篇文章给出更改grub排序的教程</p><h1 id="开始吧"><a href="#开始吧" class="headerlink" title="开始吧"></a>开始吧</h1><p>在 <strong><code>/etc/grub.d</code></strong> 目录中，脚本文件的文件名都是以数字开头，这确定了在执行 <strong><code>update-grub</code></strong> 时各文件内容被执行的顺序。找到<code>30_os-prober</code>这个文件，把<code>30_os-prober</code>这个文件名的数字30改为05到10之间的数字，比如改为<code>09_os-prober</code>，这样生成的<code>grub.cfg</code>的菜单项，windows的排序就会在ubuntu之前。<br><img src="https://s2.loli.net/2023/02/13/PpsRgmJHW1K2jC5.webp" title="grub.d目录"><br>然后更新grub， <strong><code>sudo update-grub</code></strong> ,就可以看到，windows 已经排在了第一个的位置上<br><img src="https://s2.loli.net/2023/02/13/8fEXx4ebpW61oMw.webp" title="grub的排序"><br><img src="https://s2.loli.net/2023/02/13/CkKGbovmXZ7agUu.webp" title="grub的排序"></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Grub</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Grub</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu签名内核</title>
    <link href="/202301/Ubuntu%E7%AD%BE%E5%90%8D%E5%86%85%E6%A0%B8/"/>
    <url>/202301/Ubuntu%E7%AD%BE%E5%90%8D%E5%86%85%E6%A0%B8/</url>
    
    <content type="html"><![CDATA[<h1 id="前言，起因"><a href="#前言，起因" class="headerlink" title="前言，起因"></a>前言，起因</h1><p>由于某些原因，电脑需要开启Secure Boot为了体验Linux Kernel 6.1的新特性(我也不知道要体验啥)，但Ubuntu官方还未签名新的Linux内核，于是决定自己签名内核。<br>这篇文章将带你了解如何在不关闭安全启动的情况下引导Linux内核(签名unsigned内核)</p><h1 id="了解Linux-Secure-Boot机制-基于Grub2"><a href="#了解Linux-Secure-Boot机制-基于Grub2" class="headerlink" title="了解Linux Secure Boot机制(基于Grub2)"></a>了解Linux Secure Boot机制(基于Grub2)</h1><p>安装Ubuntu时，官方会同时安装经过微软签名后的EFI文件，使得grub EFI能正确在开启安全启动的设备上启动，启动后，由grub引导内核。这时，由于grub经过安全启动，所以会验证内核是否签名，若未签名，则无法启动。</p><h1 id="安装未签名的内核"><a href="#安装未签名的内核" class="headerlink" title="安装未签名的内核"></a>安装未签名的内核</h1><p>从ubuntu官方的<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/" title="ubuntu kernel">内核源</a>选择你需要的内核，根据架构，下载对应的 <strong><code>linux-image-unsigned-xxx.deb</code></strong> 和 <strong><code>linux-modules-xxx.deb</code></strong><br><img src="https://s2.loli.net/2023/02/13/YD8o6ctS9EULCzX.webp" title="官方内核下载界面"><br>然后终端转到下载目录使用如下指令安装内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg -i ./*.deb<br></code></pre></td></tr></table></figure><p>此时，内核还没签名，如果以新安装的内核启动，则会显示 <strong><code>无效的shim签名</code></strong> ，接下来我们开始签名内核</p><h1 id="生成MOK证书"><a href="#生成MOK证书" class="headerlink" title="生成MOK证书"></a>生成MOK证书</h1><p>选择一个位置存放你的证书，以后也许会用上<br>创建MOK证书，这里需要用到 <strong><code>openssl</code></strong> ，使用如下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl req -newkey rsa:2048 -nodes -keyout MOK.key -new -x509 -sha256 -days 36500 -subj <span class="hljs-string">&quot;/CN=my Machine Owner Key/&quot;</span> -out MOK.crt<br>openssl x509 -outform DER -<span class="hljs-keyword">in</span> MOK.crt -out MOK.der<br></code></pre></td></tr></table></figure><p>将<code>der</code>格式证书转换为<code>pem</code>格式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl x509 -<span class="hljs-keyword">in</span> MOK.der -inform DER -outform PEM -out MOK.pem<br></code></pre></td></tr></table></figure><p>向机器注册MOK证书，需要安装好工具 <strong><code>mokutil</code></strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mokutil -i MOK.der<br></code></pre></td></tr></table></figure><p><code>mokutil</code>会让你设置一个密码，等下会用上，但不重要，只用一次。<br>然后重启（你也可以选择全部设置好再重启），会进入<code>MokManner</code>界面，按照要求注册你的证书。</p><h1 id="签名内核"><a href="#签名内核" class="headerlink" title="签名内核"></a>签名内核</h1><p>需要用到<code>sbsign</code>工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sbsign --key /var/lib/shim-signed/mok/MOK.priv --cert /var/lib/shim-signed/mok/MOK.pem /boot/vmlinuz-[KERNEL-VERSION]-generic --output /boot/vmlinuz-[KERNEL-VERSION]-generic.signed<br>sudo <span class="hljs-built_in">cp</span> /boot/vmlinuz-[KERNEL-VERSION]-generic.signed /boot/vmlinuz-[KERNEL-VERSION]-generic &amp;&amp; sudo <span class="hljs-built_in">rm</span> /boot/vmlinuz-[KERNEL-VERSION]-generic.signed<br></code></pre></td></tr></table></figure><p>更新grub</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-grub<br></code></pre></td></tr></table></figure><p>然后重启测试，一切顺利的话新的内核可以正常启动，有些情况会因为NVIDIA显卡驱动不适配无法启动，解决方法这里不过多阐述。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Ubuntu</category>
      
      <category>Kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>Linux Kernel</tag>
      
      <tag>Secure Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo站点收录</title>
    <link href="/202301/Hexo%E7%AB%99%E7%82%B9%E6%94%B6%E5%BD%95/"/>
    <url>/202301/Hexo%E7%AB%99%E7%82%B9%E6%94%B6%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网站在没有提交搜索引擎收录之前，直接搜索你网站的内容是搜不到的，只有提交搜索引擎之后，搜索引擎才能收录你的站点，通过爬虫抓取你网站的东西，对于 hexo 博客来说，如果你是部署在 GitHub Pages，那么你是无法被百度收录的，因为 GitHub 禁止了百度爬虫，最常见的解决办法是双线部署到 Coding Pages 和 GitHub Pages</p><h1 id="查看网站是否被收录"><a href="#查看网站是否被收录" class="headerlink" title="查看网站是否被收录"></a>查看网站是否被收录</h1><p>首先我们可以输入 <strong><code>site:域名</code></strong> 来查看域名是否被搜索引擎收录，如下图所示，表示没有收录：<br><img src="https://s2.loli.net/2023/02/13/xmzsWEGUAjkFwbS.webp" title="百度未收录"></p><h1 id="百度资源平台添加网站"><a href="#百度资源平台添加网站" class="headerlink" title="百度资源平台添加网站"></a>百度资源平台添加网站</h1><p>访问<a href="https://ziyuan.baidu.com/" title="百度搜索资源平台官网">百度搜索资源平台官网</a>，注册或者登陆百度账号，依次选择 <strong><code>用户中心</code></strong> - <strong><code>站点管理</code></strong> ，添加你的网站，但是不知道为什么始终验证失败，实在是无解，难怪百度搜不到专业的知识<br><img src="https://s2.loli.net/2023/02/13/E4CWdg9jUnBFeGl.webp" title="添加站点"><br>之后会让你验证网站所有权，提供三种验证方式：<br>文件验证：下载给定的文件，将其放到本地主题目录 source 文件夹，然后部署上去完成验证<br>HTML 标签验证：一般是给一个 meta 标签，放到首页 <strong><code>&lt;head&gt;</code></strong> 与 <strong><code>&lt;/head&gt;</code></strong> 标签之间即可完成验证</p><h1 id="提交百度搜索"><a href="#提交百度搜索" class="headerlink" title="提交百度搜索"></a>提交百度搜索</h1><p>百度提供了自动提交和手动提交两种方式，其中自动提交又分为主动推送、自动推送和 sitemap 三种方式，以下是官方给出的解释：</p><p>主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录<br>自动推送：是轻量级链接提交组件，将自动推送的 JS 代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现<br>sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送<br>手动提交：如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度</p><h2 id="sitemap"><a href="#sitemap" class="headerlink" title="sitemap"></a>sitemap</h2><p>谷歌收录里面有写到<br>类似的方法<br><a href="#a1">点击跳转</a></p><h2 id="主动推送"><a href="#主动推送" class="headerlink" title="主动推送"></a>主动推送</h2><p>在博客根目录安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-baidu-url-submit --save<br></code></pre></td></tr></table></figure><p>然后在根目录 <strong><code>_config.yml</code></strong>  文件里写入以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">baidu_url_submit:</span><br>  <span class="hljs-attr">count:</span> <span class="hljs-number">1</span>               <span class="hljs-comment"># 提交最新的多少个链接</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">blog.orii.xyz</span>    <span class="hljs-comment"># 在百度站长平台中添加的域名</span><br>  <span class="hljs-attr">token:</span> <span class="hljs-string">your_token</span>      <span class="hljs-comment"># 秘钥</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">baidu_urls.txt</span>   <span class="hljs-comment"># 文本文档的地址， 新链接会保存在此文本文档里</span><br></code></pre></td></tr></table></figure><p>其中 <strong><code>token</code></strong> 可以在【链接提交】-【自动提交】-【主动推送】下面看到，接口调用地址最后面 <strong><code>token=xxx</code></strong><br><img src="https://s2.loli.net/2023/02/13/orx9fQD2swlp7d8.webp" title="你的token"><br>同样是在根目录的 <strong><code>_config.yml</code></strong> 文件，url 要改为在百度站长平台添加的域名，也就是你网站的首页地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://blog.orii.xyz</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br></code></pre></td></tr></table></figure><p>然后，加入新的 deployer：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="hljs-attr">deploy:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span><br>    <span class="hljs-attr">github:</span> <span class="hljs-string">git@github.com:TRHX/TRHX.github.io.git</span>  <span class="hljs-comment"># 这是原来的 github 配置</span><br>    <span class="hljs-attr">coding:</span> <span class="hljs-string">git@git.dev.tencent.com:TRHX/TRHX.git</span>   <span class="hljs-comment"># 这是原来的 coding 配置</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">baidu_url_submitter</span>                         <span class="hljs-comment"># 这是新加的主动推送</span><br></code></pre></td></tr></table></figure><p>最后部署一遍即可实现主动推送</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g -d<br></code></pre></td></tr></table></figure><h1 id="提交谷歌搜索"><a href="#提交谷歌搜索" class="headerlink" title="提交谷歌搜索"></a>提交谷歌搜索</h1><p>提交谷歌搜索引擎比较简单，进入<a href="https://www.google.com/webmasters/tools/" title="谷歌站长平台">谷歌站长平台</a>，登录你的谷歌账号之后会让你验证网站所有权：<br>略~~~</p><div id="a1"></div><h2 id="sitemap-1"><a href="#sitemap-1" class="headerlink" title="sitemap"></a>sitemap</h2><p>首先我们要使用以下命令生成一个网站地图：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-generator-sitemap --save     <br>npm install hexo-generator-baidu-sitemap --save<br></code></pre></td></tr></table></figure><p>同样是在根目录的 <strong><code>_config.yml</code></strong> 文件，url 要改为在站长平台添加的域名，也就是你网站的首页地址：<br>同样是在根目录的 <strong><code>_config.yml</code></strong> 文件，url 要改为在百度站长平台添加的域名，也就是你网站的首页地址：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://blog.orii.xyz</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br></code></pre></td></tr></table></figure><p>然后使用命令将网站部署上去</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g -d<br></code></pre></td></tr></table></figure><p>然后访问 <strong><code>你的首页/sitemap.xml</code></strong> 或者 <strong><code>你的首页/baidusitemap.xml</code></strong> 就可以看到网站地图了<br>其中 <strong><code>sitemap.xml</code></strong> 文件是搜索引擎通用的 sitemap 文件， <strong><code>baidusitemap.xml</code></strong> 是百度专用的 sitemap 文件</p><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>提交谷歌收录比较简单，选择站点地图，将我们之前生成的 sitemap 提交就行了，过几分钟刷新一下看到成功字样表示提交成功！<br><img src="https://s2.loli.net/2023/02/13/Y8lHTo53gWjAqVS.webp" title="sitemap"></p><h1 id="提交必应收录"><a href="#提交必应收录" class="headerlink" title="提交必应收录"></a>提交必应收录</h1><p>必应收录也是很简单，进入<a href="https://www.bing.com/webmaster/home/mysites" title="必应站长">必应站长</a>。注册或登录，必应收录有两种方式，一种使用刚刚谷歌导入过去，第二种是就是自己添加URL<br><img src="https://s2.loli.net/2023/02/13/RBK4ENTLuf6UMHX.webp" title="bing导入站点"><br>之后，你可以提交站点地图，bing的站点地图提交后会马上抓取。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>各大搜索引擎的站点提交都大差不差，原理和操作流程都差不多，可以使用类似方法提交。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Blog</category>
      
      <category>SEO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>Blog</tag>
      
      <tag>SEO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇博客，hexo+GitHub搭建</title>
    <link href="/202211/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8Chexo-GitHub%E6%90%AD%E5%BB%BA/"/>
    <url>/202211/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8Chexo-GitHub%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="个人博客搭建，hexo-github"><a href="#个人博客搭建，hexo-github" class="headerlink" title="个人博客搭建，hexo+github"></a>个人博客搭建，hexo+github</h1><h2 id="前言与准备："><a href="#前言与准备：" class="headerlink" title="前言与准备："></a>前言与准备：</h2><h3 id="准备好一个GitHub账号"><a href="#准备好一个GitHub账号" class="headerlink" title="准备好一个GitHub账号"></a>准备好一个GitHub账号</h3><p>创建方法略</p><h3 id="安装nodejs"><a href="#安装nodejs" class="headerlink" title="安装nodejs"></a>安装nodejs</h3><p>略，官网安装</p><h3 id="安装hexo等环境"><a href="#安装hexo等环境" class="headerlink" title="安装hexo等环境"></a>安装hexo等环境</h3><p>命令行输入以下指令进行安装  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli hexo-deployer-git<br></code></pre></td></tr></table></figure><p>准备工作完成  </p><h2 id="Github设置"><a href="#Github设置" class="headerlink" title="Github设置"></a>Github设置</h2><h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号：Build software better, together 点击GitHub中的New repository创建新仓库  </p><h3 id="绑定个人域名-可选"><a href="#绑定个人域名-可选" class="headerlink" title="绑定个人域名(可选)"></a>绑定个人域名(可选)</h3><p>点击创建好的仓库，依次点击 <strong><code>Settings &gt; Pages</code></strong>,在 <strong><code>Custom domain</code></strong> 填入域名，点击 <strong><code>save</code></strong> 保存<br>在你的域名服务商添加CNAME记录, <strong><code>&lt;你的GitHub名字&gt;.github.io</code></strong> ，等待解析生效。打开Enforce HTTPS选项(可选，建议)<br><img src="https://s2.loli.net/2023/02/13/7v6xbCHrz3siITL.webp" title="Github域名设置"><br>也可以使用vercel等加速你的博客(可选，略，目前我用的就是vercel)  </p><h2 id="hexo的使用"><a href="#hexo的使用" class="headerlink" title="hexo的使用"></a>hexo的使用</h2><p>略(暂时?!)，可参照网上的各种帖子<br><a href="https://blog.csdn.net/yaorongke/article/details/119089190" title="GitHub+Hexo 搭建个人网站详细教程">搭建教程</a><br><a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Blog</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
