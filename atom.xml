<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>orii博客</title>
  
  <subtitle>GentsunCheng的个人博客</subtitle>
  <link href="https://blog.orii.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.orii.xyz/"/>
  <updated>2023-04-16T08:18:34.000Z</updated>
  <id>https://blog.orii.xyz/</id>
  
  <author>
    <name>Gentsun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用微软官方工具GraphExplorer添加&amp;修改API应用密钥时间</title>
    <link href="https://blog.orii.xyz/202304/%E5%88%A9%E7%94%A8%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E5%B7%A5%E5%85%B7GraphExplorer%E6%B7%BB%E5%8A%A0-%E4%BF%AE%E6%94%B9API%E5%BA%94%E7%94%A8%E5%AF%86%E9%92%A5%E6%97%B6%E9%97%B4/"/>
    <id>https://blog.orii.xyz/202304/%E5%88%A9%E7%94%A8%E5%BE%AE%E8%BD%AF%E5%AE%98%E6%96%B9%E5%B7%A5%E5%85%B7GraphExplorer%E6%B7%BB%E5%8A%A0-%E4%BF%AE%E6%94%B9API%E5%BA%94%E7%94%A8%E5%AF%86%E9%92%A5%E6%97%B6%E9%97%B4/</id>
    <published>2023-04-16T08:18:34.000Z</published>
    <updated>2023-04-16T08:18:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>现在 Microsoft 365 / Office 365 A1 A1P E3 MSDN 等添加 API后，应用密钥时间最多是两年，以防万一，我们当然希望应用密钥时间越长越好，其实官方给出了相应的方法具体可参照官方文档<ahref="https://docs.microsoft.com/zh-CN/graph/api/overview?view=graph-rest-1.0"></a></p><h1 id="正式开始">正式开始</h1><p>打开<ahref="https://developer.microsoft.com/zh-cn/graph/graph-explorer"></a></p><p>使用全局管理员账号登录(你注册使用的微软账户)<br />在 <strong>修改权限</strong> 中同意授权<br /><img src="https://s2.loli.net/2023/04/16/OsrV1ag7HdoN2Ut.webp"title="修改权限" /> 请求头修改为 <strong>POST</strong> 将<strong>0cbb7e9f-23fc-4e4c-8fc8-1008611NB</strong> 修改为你应用程序中的<strong>对象 ID</strong><br /><code>https://graph.microsoft.com/v1.0/applications/&#123;0cbb7e9f-23fc-4e4c-8fc8-1008611NB&#125;/addPassword</code></p><p>displayName 为密钥名称，可随意设置</p><p>endDateTime 为密钥到期时间，可随意设置</p><p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;passwordCredential&quot;</span><span class="hljs-punctuation">:</span> <br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;displayName&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;microsoft&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;endDateTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2299-05-07T00:00:00Z&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p><p><img src="https://s2.loli.net/2023/04/16/gMsQGWCtEw1akn6.webp"title="请求设置" /></p><p>设置好后，点击 <strong>运行查询</strong><br />返回结果如下 <imgsrc="https://s2.loli.net/2023/04/16/YNzBuAKDHxETQoh.webp"title="返回结果" /> keyId 为 Secret ID<br />secretText 为新的应用密钥，<strong>请一定要记牢</strong></p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>为你的Hexo博客适配PWA</title>
    <link href="https://blog.orii.xyz/202302/%E4%B8%BA%E4%BD%A0%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E9%80%82%E9%85%8DPWA/"/>
    <id>https://blog.orii.xyz/202302/%E4%B8%BA%E4%BD%A0%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E9%80%82%E9%85%8DPWA/</id>
    <published>2023-02-14T12:37:52.000Z</published>
    <updated>2023-02-14T12:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>在阅读这篇博客之前，我们可简单的了解pwa，pwa是什么，pwa有什么优势，会给你的网站带来哪些提升。</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="Web" scheme="https://blog.orii.xyz/categories/Web/"/>
    
    <category term="Blog" scheme="https://blog.orii.xyz/categories/Web/Blog/"/>
    
    
    <category term="Web" scheme="https://blog.orii.xyz/tags/Web/"/>
    
    <category term="Blog" scheme="https://blog.orii.xyz/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>使用cloudflare Worker代理telegram bot api</title>
    <link href="https://blog.orii.xyz/202301/%E4%BD%BF%E7%94%A8cloudflare-Worker%E4%BB%A3%E7%90%86telegram-bot-api/"/>
    <id>https://blog.orii.xyz/202301/%E4%BD%BF%E7%94%A8cloudflare-Worker%E4%BB%A3%E7%90%86telegram-bot-api/</id>
    <published>2023-01-22T06:05:16.000Z</published>
    <updated>2023-01-22T06:05:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>众所周知，Telegram不在中国提供服务，以至于Telegram botapi无法使用。并且我们要在程序中使用Telegram botapi时，代理程序不好写进去，一般都会使用系统代理或干脆直接tun模式来强制程序代理。这时不妨换个思路，使用cloudflare代理telegrambotapi。（也可以在vps上使用nginx反代。但白嫖cloudflare更爽，要实现真正完全白嫖，还可以在<strong><code>eu.org</code></strong> 白嫖一个域名，这里不细说</p><h1 id="创建workers反代项目">创建Workers反代项目</h1><p>登录cloudflare，点击workers <imgsrc="https://s2.loli.net/2023/02/13/qOy3flN5eoUECJp.webp"title="cloudflare workers" /> 点击创建服务 <imgsrc="https://s2.loli.net/2023/02/13/AcPCHTvSBoUJmbI.webp"title="创建" /> 名称随意填写，但是下面需要选择<strong>HTTP路由器</strong> <imgsrc="https://s2.loli.net/2023/02/13/UROmDoHbqtAY1NS.webp" />创建完成后，点击刚创建的Worker，再点击快速编辑 <imgsrc="https://s2.loli.net/2023/02/13/MVrma3lU59bySeO.webp" />删除红框处所有的代码，填入以下代码 <imgsrc="https://s2.loli.net/2023/02/13/ozEXLUP9BfxC4Ha.webp" /><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Helper functions to check if the request uses</span><br><span class="hljs-comment"> * corresponding method.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Method</span> = (<span class="hljs-params">method</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> req.<span class="hljs-property">method</span>.<span class="hljs-title function_">toLowerCase</span>() === method.<span class="hljs-title function_">toLowerCase</span>();<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Get</span> = <span class="hljs-title class_">Method</span>(<span class="hljs-string">&#x27;get&#x27;</span>);<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Post</span> = <span class="hljs-title class_">Method</span>(<span class="hljs-string">&#x27;post&#x27;</span>);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">Path</span> = (<span class="hljs-params">regExp</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(req.<span class="hljs-property">url</span>);<br><span class="hljs-keyword">const</span> path = url.<span class="hljs-property">pathname</span>;<br><span class="hljs-keyword">return</span> path.<span class="hljs-title function_">match</span>(regExp) &amp;&amp; path.<span class="hljs-title function_">match</span>(regExp)[<span class="hljs-number">0</span>] === path;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * The regex to get the bot_token and api_method from request URL</span><br><span class="hljs-comment"> * as the first and second backreference respectively.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">URL_PATH_REGEX</span> = <span class="hljs-regexp">/^\/bot(?&lt;bot_token&gt;[^/]+)\/(?&lt;api_method&gt;[a-z]+)/i</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Router handles the logic of what handler is matched given conditions</span><br><span class="hljs-comment"> * for each request</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Router</span> &#123;<br><span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span> = [];<br>&#125;<br><br><span class="hljs-title function_">handle</span>(<span class="hljs-params">conditions, handler</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>.<span class="hljs-title function_">push</span>(&#123;<br>conditions,<br>handler,<br>&#125;);<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br><br><span class="hljs-title function_">get</span>(<span class="hljs-params">url, handler</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handle</span>([<span class="hljs-title class_">Get</span>, <span class="hljs-title class_">Path</span>(url)], handler);<br>&#125;<br><br><span class="hljs-title function_">post</span>(<span class="hljs-params">url, handler</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handle</span>([<span class="hljs-title class_">Post</span>, <span class="hljs-title class_">Path</span>(url)], handler);<br>&#125;<br><br><span class="hljs-title function_">all</span>(<span class="hljs-params">handler</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">handler</span>([], handler);<br>&#125;<br><br><span class="hljs-title function_">route</span>(<span class="hljs-params">req</span>) &#123;<br><span class="hljs-keyword">const</span> route = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">resolve</span>(req);<br><br><span class="hljs-keyword">if</span> (route) &#123;<br><span class="hljs-keyword">return</span> route.<span class="hljs-title function_">handler</span>(req);<br>&#125;<br><br><span class="hljs-keyword">const</span> description = <span class="hljs-string">&#x27;No matching route found&#x27;</span>;<br><span class="hljs-keyword">const</span> error_code = <span class="hljs-number">404</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<br><span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<br><span class="hljs-attr">ok</span>: <span class="hljs-literal">false</span>,<br>error_code,<br>description,<br>&#125;),<br>&#123;<br><span class="hljs-attr">status</span>: error_code,<br><span class="hljs-attr">statusText</span>: description,<br><span class="hljs-attr">headers</span>: &#123;<br><span class="hljs-string">&#x27;content-type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>&#125;,<br>&#125;<br>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * It returns the matching route that returns true</span><br><span class="hljs-comment"> * for all the conditions if any.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">resolve</span>(<span class="hljs-params">req</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">routes</span>.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">r</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">if</span> (!r.<span class="hljs-property">conditions</span> || (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(r) &amp;&amp; !r.<span class="hljs-property">conditions</span>.<span class="hljs-property">length</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> r.<span class="hljs-property">conditions</span> === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br><span class="hljs-keyword">return</span> r.<span class="hljs-title function_">conditions</span>(req);<br>&#125;<br><br><span class="hljs-keyword">return</span> r.<span class="hljs-property">conditions</span>.<span class="hljs-title function_">every</span>(<span class="hljs-function">(<span class="hljs-params">c</span>) =&gt;</span> <span class="hljs-title function_">c</span>(req));<br>&#125;);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sends a POST request with JSON data to Telegram Bot API</span><br><span class="hljs-comment"> * and reads in the response body.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Request</span>&#125; request the incoming request</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handler</span>(<span class="hljs-params">request</span>) &#123;<br><span class="hljs-comment">// Extract the URl method from the request.</span><br><span class="hljs-keyword">const</span> &#123; url, ..._request &#125; = request;<br><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">pathname</span>: path, search &#125; = <span class="hljs-keyword">new</span> <span class="hljs-title function_">URL</span>(url);<br><br><span class="hljs-comment">// Leave the first match as we are interested only in backreferences.</span><br><span class="hljs-keyword">const</span> &#123; bot_token, api_method &#125; = path.<span class="hljs-title function_">match</span>(<span class="hljs-variable constant_">URL_PATH_REGEX</span>).<span class="hljs-property">groups</span>;<br><br><span class="hljs-comment">// Build the URL</span><br><span class="hljs-keyword">const</span> api_url = <span class="hljs-string">&#x27;https://api.telegram.org/bot&#x27;</span> + bot_token + <span class="hljs-string">&#x27;/&#x27;</span> + api_method + search;<br><br><span class="hljs-comment">// Get the response from API.</span><br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(api_url, _request);<br><br><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">text</span>();<br><br><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(result, _request);<br><br>res.<span class="hljs-property">headers</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>);<br><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Handles the incoming request.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type">Request</span>&#125; request the incoming request.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleRequest</span>(<span class="hljs-params">request</span>) &#123;<br><span class="hljs-keyword">const</span> r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>();<br>r.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">URL_PATH_REGEX</span>, <span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> <span class="hljs-title function_">handler</span>(req));<br>r.<span class="hljs-title function_">post</span>(<span class="hljs-variable constant_">URL_PATH_REGEX</span>, <span class="hljs-function">(<span class="hljs-params">req</span>) =&gt;</span> <span class="hljs-title function_">handler</span>(req));<br><br><span class="hljs-keyword">const</span> resp = <span class="hljs-keyword">await</span> r.<span class="hljs-title function_">route</span>(request);<br><span class="hljs-keyword">return</span> resp;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Hook into the fetch event.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>event.<span class="hljs-title function_">respondWith</span>(<span class="hljs-title function_">handleRequest</span>(event.<span class="hljs-property">request</span>));<br>&#125;);<br></code></pre></td></tr></table></figure> 然后保存并部署，之后可以在触发器中添加自己的域名 <imgsrc="https://s2.loli.net/2023/02/13/Wkbm8F4ifGn3Pd1.webp" /></p><h1 id="使用">使用</h1><p>之后，只需要把telegram api地址替换成<strong><code>https://yourdomain.xxx</code></strong> 即可</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="Web" scheme="https://blog.orii.xyz/categories/Web/"/>
    
    <category term="CDN" scheme="https://blog.orii.xyz/categories/Web/CDN/"/>
    
    
    <category term="Web" scheme="https://blog.orii.xyz/tags/Web/"/>
    
    <category term="CDN" scheme="https://blog.orii.xyz/tags/CDN/"/>
    
    <category term="Telegram" scheme="https://blog.orii.xyz/tags/Telegram/"/>
    
    <category term="Cloudflare" scheme="https://blog.orii.xyz/tags/Cloudflare/"/>
    
  </entry>
  
  <entry>
    <title>RSS介绍+为你的Hexo博客添加RSS</title>
    <link href="https://blog.orii.xyz/202301/RSS%E4%BB%8B%E7%BB%8D-%E4%B8%BA%E4%BD%A0%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS/"/>
    <id>https://blog.orii.xyz/202301/RSS%E4%BB%8B%E7%BB%8D-%E4%B8%BA%E4%BD%A0%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0RSS/</id>
    <published>2023-01-22T06:03:59.000Z</published>
    <updated>2023-01-22T06:03:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="rss介绍">RSS介绍</h1><p>暂时略~~~</p><h1 id="为hexo添加rss">为Hexo添加RSS</h1><h2 id="hexo-generator-feed插件">hexo-generator-feed插件</h2><p>在Hexo目录下使用如下指令安装RSS生成工具，<strong><code>hexo-generator-feed</code></strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-generator-feed<br></code></pre></td></tr></table></figure> 在<strong><code>_config.yml</code></strong> 文件添加配置 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feed:</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">atom</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">atom.xml</span><br>    <span class="hljs-attr">limit:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">hub:</span><br>    <span class="hljs-attr">content:</span><br>    <span class="hljs-attr">content_limit:</span><br>    <span class="hljs-attr">content_limit_delim:</span> <span class="hljs-string">&#x27; &#x27;</span><br></code></pre></td></tr></table></figure>参数的含义： <code>type</code>:RSS的类型(<code>atom</code>/<code>rss2</code>) <code>path</code>:文件路径,默认是<code>atom.xml</code>/<code>rss2.xml</code><code>limit</code>:展示文章的数量,使用<code>0</code>或则<code>false</code>代表展示全部<code>hub</code>: <code>content</code>: 在RSS文件中是否包含内容 ,有3个值<code>true/false</code>默认不填为<code>false</code><code>content_limit</code>:指定内容的长度作为摘要,仅仅在上面content设置为false和没有自定义的描述出现<code>content_limit_delim</code>:上面截取描述的分隔符,截取内容是以指定的这个分隔符作为截取结束的标志.在达到规定的内容长度之前最后出现的这个分隔符之前的内容,，防止从中间截断.之后使用<code>http(s)://你的博客地址/atom.xml #http(s)://你的博客地址/rss2.xml</code>订阅</p><h2 id="主题自带以next主题为例">主题自带（以Next主题为例）</h2><p>在 <strong><code>Next</code></strong> 主题的<strong><code>_config.yml</code></strong> 文件中有个<strong>rss</strong> 的配置，直接设置为 <strong>true</strong>其他主题可在使用手册查看是否支持，如何开启</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="Web" scheme="https://blog.orii.xyz/categories/Web/"/>
    
    <category term="Blog" scheme="https://blog.orii.xyz/categories/Web/Blog/"/>
    
    <category term="RSS" scheme="https://blog.orii.xyz/categories/Web/Blog/RSS/"/>
    
    
    <category term="Web" scheme="https://blog.orii.xyz/tags/Web/"/>
    
    <category term="Blog" scheme="https://blog.orii.xyz/tags/Blog/"/>
    
    <category term="RSS" scheme="https://blog.orii.xyz/tags/RSS/"/>
    
  </entry>
  
  <entry>
    <title>Grub更改排序(不是默认启动项)</title>
    <link href="https://blog.orii.xyz/202301/Grub%E6%9B%B4%E6%94%B9%E6%8E%92%E5%BA%8F-%E4%B8%8D%E6%98%AF%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E9%A1%B9/"/>
    <id>https://blog.orii.xyz/202301/Grub%E6%9B%B4%E6%94%B9%E6%8E%92%E5%BA%8F-%E4%B8%8D%E6%98%AF%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E9%A1%B9/</id>
    <published>2023-01-19T03:42:31.000Z</published>
    <updated>2023-01-19T03:42:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>由于主要使用Windows，但按照常规方法设置grub默认启动项后，会(强)十(迫)分(症)影(受)响(不)美(了)观，所以，这篇文章给出更改grub排序的教程</p><h1 id="开始吧">开始吧</h1><p>在 <strong><code>/etc/grub.d</code></strong>目录中，脚本文件的文件名都是以数字开头，这确定了在执行<strong><code>update-grub</code></strong>时各文件内容被执行的顺序。找到<code>30_os-prober</code>这个文件，把<code>30_os-prober</code>这个文件名的数字30改为05到10之间的数字，比如改为<code>09_os-prober</code>，这样生成的<code>grub.cfg</code>的菜单项，windows的排序就会在ubuntu之前。<img src="https://s2.loli.net/2023/02/13/PpsRgmJHW1K2jC5.webp"title="grub.d目录" /> 然后更新grub，<strong><code>sudo update-grub</code></strong> ,就可以看到，windows已经排在了第一个的位置上 <imgsrc="https://s2.loli.net/2023/02/13/8fEXx4ebpW61oMw.webp"title="grub的排序" /> <imgsrc="https://s2.loli.net/2023/02/13/CkKGbovmXZ7agUu.webp"title="grub的排序" /></p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="Linux" scheme="https://blog.orii.xyz/categories/Linux/"/>
    
    <category term="Grub" scheme="https://blog.orii.xyz/categories/Linux/Grub/"/>
    
    
    <category term="Linux" scheme="https://blog.orii.xyz/tags/Linux/"/>
    
    <category term="Grub" scheme="https://blog.orii.xyz/tags/Grub/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu签名内核</title>
    <link href="https://blog.orii.xyz/202301/Ubuntu%E7%AD%BE%E5%90%8D%E5%86%85%E6%A0%B8/"/>
    <id>https://blog.orii.xyz/202301/Ubuntu%E7%AD%BE%E5%90%8D%E5%86%85%E6%A0%B8/</id>
    <published>2023-01-18T03:45:14.000Z</published>
    <updated>2023-01-18T03:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言起因">前言，起因</h1><p>由于某些原因，电脑需要开启Secure Boot为了体验Linux Kernel6.1的新特性(我也不知道要体验啥)，但Ubuntu官方还未签名新的Linux内核，于是决定自己签名内核。这篇文章将带你了解如何在不关闭安全启动的情况下引导Linux内核(签名unsigned内核)</p><h1 id="了解linux-secure-boot机制基于grub2">了解Linux SecureBoot机制(基于Grub2)</h1><p>安装Ubuntu时，官方会同时安装经过微软签名后的EFI文件，使得grubEFI能正确在开启安全启动的设备上启动，启动后，由grub引导内核。这时，由于grub经过安全启动，所以会验证内核是否签名，若未签名，则无法启动。</p><h1 id="安装未签名的内核">安装未签名的内核</h1><p>从ubuntu官方的<ahref="https://kernel.ubuntu.com/~kernel-ppa/mainline/"title="ubuntu kernel">内核源</a>选择你需要的内核，根据架构，下载对应的<strong><code>linux-image-unsigned-xxx.deb</code></strong> 和<strong><code>linux-modules-xxx.deb</code></strong> <imgsrc="https://s2.loli.net/2023/02/13/YD8o6ctS9EULCzX.webp"title="官方内核下载界面" /> 然后终端转到下载目录使用如下指令安装内核<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dpkg -i ./*.deb<br></code></pre></td></tr></table></figure> 此时，内核还没签名，如果以新安装的内核启动，则会显示<strong><code>无效的shim签名</code></strong>，接下来我们开始签名内核</p><h1 id="生成mok证书">生成MOK证书</h1><p>选择一个位置存放你的证书，以后也许会用上<br />创建MOK证书，这里需要用到 <strong><code>openssl</code></strong>，使用如下指令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl req -newkey rsa:2048 -nodes -keyout MOK.key -new -x509 -sha256 -days 36500 -subj <span class="hljs-string">&quot;/CN=my Machine Owner Key/&quot;</span> -out MOK.crt<br>openssl x509 -outform DER -<span class="hljs-keyword">in</span> MOK.crt -out MOK.der<br></code></pre></td></tr></table></figure>将<code>der</code>格式证书转换为<code>pem</code>格式 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">openssl x509 -<span class="hljs-keyword">in</span> MOK.der -inform DER -outform PEM -out MOK.pem<br></code></pre></td></tr></table></figure>向机器注册MOK证书，需要安装好工具 <strong><code>mokutil</code></strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mokutil -i MOK.der<br></code></pre></td></tr></table></figure><code>mokutil</code>会让你设置一个密码，等下会用上，但不重要，只用一次。<br />然后重启（你也可以选择全部设置好再重启），会进入<code>MokManner</code>界面，按照要求注册你的证书。</p><h1 id="签名内核">签名内核</h1><p>需要用到<code>sbsign</code>工具 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo sbsign --key /var/lib/shim-signed/mok/MOK.priv --cert /var/lib/shim-signed/mok/MOK.pem /boot/vmlinuz-[KERNEL-VERSION]-generic --output /boot/vmlinuz-[KERNEL-VERSION]-generic.signed<br>sudo <span class="hljs-built_in">cp</span> /boot/vmlinuz-[KERNEL-VERSION]-generic.signed /boot/vmlinuz-[KERNEL-VERSION]-generic &amp;&amp; sudo <span class="hljs-built_in">rm</span> /boot/vmlinuz-[KERNEL-VERSION]-generic.signed<br></code></pre></td></tr></table></figure> 更新grub <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo update-grub<br></code></pre></td></tr></table></figure>然后重启测试，一切顺利的话新的内核可以正常启动，有些情况会因为NVIDIA显卡驱动不适配无法启动，解决方法这里不过多阐述。</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="Linux" scheme="https://blog.orii.xyz/categories/Linux/"/>
    
    <category term="Ubuntu" scheme="https://blog.orii.xyz/categories/Linux/Ubuntu/"/>
    
    <category term="Kernel" scheme="https://blog.orii.xyz/categories/Linux/Kernel/"/>
    
    
    <category term="Ubuntu" scheme="https://blog.orii.xyz/tags/Ubuntu/"/>
    
    <category term="Linux Kernel" scheme="https://blog.orii.xyz/tags/Linux-Kernel/"/>
    
    <category term="Secure Boot" scheme="https://blog.orii.xyz/tags/Secure-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Hexo站点收录</title>
    <link href="https://blog.orii.xyz/202301/Hexo%E7%AB%99%E7%82%B9%E6%94%B6%E5%BD%95/"/>
    <id>https://blog.orii.xyz/202301/Hexo%E7%AB%99%E7%82%B9%E6%94%B6%E5%BD%95/</id>
    <published>2023-01-18T01:40:49.000Z</published>
    <updated>2023-01-18T01:40:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>网站在没有提交搜索引擎收录之前，直接搜索你网站的内容是搜不到的，只有提交搜索引擎之后，搜索引擎才能收录你的站点，通过爬虫抓取你网站的东西，对于hexo 博客来说，如果你是部署在 GitHubPages，那么你是无法被百度收录的，因为 GitHub禁止了百度爬虫，最常见的解决办法是双线部署到 Coding Pages 和 GitHubPages</p><h1 id="查看网站是否被收录">查看网站是否被收录</h1><p>首先我们可以输入 <strong><code>site:域名</code></strong>来查看域名是否被搜索引擎收录，如下图所示，表示没有收录： <imgsrc="https://s2.loli.net/2023/02/13/xmzsWEGUAjkFwbS.webp"title="百度未收录" /></p><h1 id="百度资源平台添加网站">百度资源平台添加网站</h1><p>访问<a href="https://ziyuan.baidu.com/"title="百度搜索资源平台官网">百度搜索资源平台官网</a>，注册或者登陆百度账号，依次选择<strong><code>用户中心</code></strong> -<strong><code>站点管理</code></strong>，添加你的网站，但是不知道为什么始终验证失败，实在是无解，难怪百度搜不到专业的知识<img src="https://s2.loli.net/2023/02/13/E4CWdg9jUnBFeGl.webp"title="添加站点" /> 之后会让你验证网站所有权，提供三种验证方式：文件验证：下载给定的文件，将其放到本地主题目录 source文件夹，然后部署上去完成验证 HTML 标签验证：一般是给一个 meta标签，放到首页 <strong><code>&lt;head&gt;</code></strong> 与<strong><code>&lt;/head&gt;</code></strong> 标签之间即可完成验证</p><h1 id="提交百度搜索">提交百度搜索</h1><p>百度提供了自动提交和手动提交两种方式，其中自动提交又分为主动推送、自动推送和sitemap 三种方式，以下是官方给出的解释：</p><p>主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录自动推送：是轻量级链接提交组件，将自动推送的 JS代码放置在站点每一个页面源代码中，当页面被访问时，页面链接会自动推送给百度，有利于新页面更快被百度发现sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送手动提交：如果您不想通过程序提交，那么可以采用此种方式，手动将链接提交给百度</p><h2 id="sitemap">sitemap</h2><p>谷歌收录里面有写到 类似的方法 <a href="#a1">点击跳转</a></p><h2 id="主动推送">主动推送</h2><p>在博客根目录安装插件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-baidu-url-submit --save<br></code></pre></td></tr></table></figure> 然后在根目录<strong><code>_config.yml</code></strong> 文件里写入以下配置：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">baidu_url_submit:</span><br>  <span class="hljs-attr">count:</span> <span class="hljs-number">1</span>               <span class="hljs-comment"># 提交最新的多少个链接</span><br>  <span class="hljs-attr">host:</span> <span class="hljs-string">blog.orii.xyz</span>    <span class="hljs-comment"># 在百度站长平台中添加的域名</span><br>  <span class="hljs-attr">token:</span> <span class="hljs-string">your_token</span>      <span class="hljs-comment"># 秘钥</span><br>  <span class="hljs-attr">path:</span> <span class="hljs-string">baidu_urls.txt</span>   <span class="hljs-comment"># 文本文档的地址， 新链接会保存在此文本文档里</span><br></code></pre></td></tr></table></figure> 其中 <strong><code>token</code></strong>可以在【链接提交】-【自动提交】-【主动推送】下面看到，接口调用地址最后面<strong><code>token=xxx</code></strong> <imgsrc="https://s2.loli.net/2023/02/13/orx9fQD2swlp7d8.webp"title="你的token" /> 同样是在根目录的<strong><code>_config.yml</code></strong> 文件，url要改为在百度站长平台添加的域名，也就是你网站的首页地址： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://blog.orii.xyz</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br></code></pre></td></tr></table></figure>然后，加入新的 deployer： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Deployment</span><br><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="hljs-attr">deploy:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repository:</span><br>    <span class="hljs-attr">github:</span> <span class="hljs-string">git@github.com:TRHX/TRHX.github.io.git</span>  <span class="hljs-comment"># 这是原来的 github 配置</span><br>    <span class="hljs-attr">coding:</span> <span class="hljs-string">git@git.dev.tencent.com:TRHX/TRHX.git</span>   <span class="hljs-comment"># 这是原来的 coding 配置</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">type:</span> <span class="hljs-string">baidu_url_submitter</span>                         <span class="hljs-comment"># 这是新加的主动推送</span><br></code></pre></td></tr></table></figure> 最后部署一遍即可实现主动推送<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g -d<br></code></pre></td></tr></table></figure></p><h1 id="提交谷歌搜索">提交谷歌搜索</h1>提交谷歌搜索引擎比较简单，进入<ahref="https://www.google.com/webmasters/tools/"title="谷歌站长平台">谷歌站长平台</a>，登录你的谷歌账号之后会让你验证网站所有权：略~~~<div id="a1"></div><h2 id="sitemap-1">sitemap</h2><p>首先我们要使用以下命令生成一个网站地图： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-generator-sitemap --save     <br>npm install hexo-generator-baidu-sitemap --save<br></code></pre></td></tr></table></figure>同样是在根目录的 <strong><code>_config.yml</code></strong> 文件，url要改为在站长平台添加的域名，也就是你网站的首页地址： 同样是在根目录的<strong><code>_config.yml</code></strong> 文件，url要改为在百度站长平台添加的域名，也就是你网站的首页地址： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># URL</span><br><span class="hljs-attr">url:</span> <span class="hljs-string">https://blog.orii.xyz</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">permalink:</span> <span class="hljs-string">:year/:month/:day/:title/</span><br></code></pre></td></tr></table></figure>然后使用命令将网站部署上去 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo g -d<br></code></pre></td></tr></table></figure> 然后访问<strong><code>你的首页/sitemap.xml</code></strong> 或者<strong><code>你的首页/baidusitemap.xml</code></strong>就可以看到网站地图了 其中 <strong><code>sitemap.xml</code></strong>文件是搜索引擎通用的 sitemap 文件，<strong><code>baidusitemap.xml</code></strong> 是百度专用的 sitemap文件</p><h2 id="提交">提交</h2><p>提交谷歌收录比较简单，选择站点地图，将我们之前生成的 sitemap提交就行了，过几分钟刷新一下看到成功字样表示提交成功！ <imgsrc="https://s2.loli.net/2023/02/13/Y8lHTo53gWjAqVS.webp"title="sitemap" /></p><h1 id="提交必应收录">提交必应收录</h1><p>必应收录也是很简单，进入<ahref="https://www.bing.com/webmaster/home/mysites"title="必应站长">必应站长</a>。注册或登录，必应收录有两种方式，一种使用刚刚谷歌导入过去，第二种是就是自己添加URL<img src="https://s2.loli.net/2023/02/13/RBK4ENTLuf6UMHX.webp"title="bing导入站点" />之后，你可以提交站点地图，bing的站点地图提交后会马上抓取。</p><h1 id="总结">总结</h1><p>各大搜索引擎的站点提交都大差不差，原理和操作流程都差不多，可以使用类似方法提交。</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="Web" scheme="https://blog.orii.xyz/categories/Web/"/>
    
    <category term="Blog" scheme="https://blog.orii.xyz/categories/Web/Blog/"/>
    
    <category term="SEO" scheme="https://blog.orii.xyz/categories/Web/Blog/SEO/"/>
    
    
    <category term="Web" scheme="https://blog.orii.xyz/tags/Web/"/>
    
    <category term="Blog" scheme="https://blog.orii.xyz/tags/Blog/"/>
    
    <category term="SEO" scheme="https://blog.orii.xyz/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客，hexo+GitHub搭建</title>
    <link href="https://blog.orii.xyz/202211/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8Chexo-GitHub%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.orii.xyz/202211/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8Chexo-GitHub%E6%90%AD%E5%BB%BA/</id>
    <published>2022-11-03T06:39:10.000Z</published>
    <updated>2022-11-03T06:39:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="个人博客搭建hexogithub">个人博客搭建，hexo+github</h1><h2 id="前言与准备">前言与准备：</h2><h3 id="准备好一个github账号">准备好一个GitHub账号</h3><p>创建方法略 ### 安装nodejs 略，官网安装 ### 安装hexo等环境命令行输入以下指令进行安装<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli hexo-deployer-git<br></code></pre></td></tr></table></figure> 准备工作完成</p><h2 id="github设置">Github设置</h2><h3 id="github创建个人仓库">GitHub创建个人仓库</h3><p>登录到GitHub,如果没有GitHub帐号，使用你的邮箱注册GitHub帐号：Buildsoftware better, together 点击GitHub中的New repository创建新仓库</p><h3 id="绑定个人域名可选">绑定个人域名(可选)</h3><p>点击创建好的仓库，依次点击<strong><code>Settings &gt; Pages</code></strong>,在<strong><code>Custom domain</code></strong> 填入域名，点击<strong><code>save</code></strong> 保存<br />在你的域名服务商添加CNAME记录,<strong><code>&lt;你的GitHub名字&gt;.github.io</code></strong>，等待解析生效。打开Enforce HTTPS选项(可选，建议)<br /><img src="https://s2.loli.net/2023/02/13/7v6xbCHrz3siITL.webp"title="Github域名设置" />也可以使用vercel等加速你的博客(可选，略，目前我用的就是vercel)</p><h2 id="hexo的使用">hexo的使用</h2><p>略(暂时?!)，可参照网上的各种帖子<br /><a href="https://blog.csdn.net/yaorongke/article/details/119089190"title="GitHub+Hexo 搭建个人网站详细教程">搭建教程</a> <ahref="https://markdown.com.cn"title="最好的markdown教程">Markdown语法</a></p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="Web" scheme="https://blog.orii.xyz/categories/Web/"/>
    
    <category term="Blog" scheme="https://blog.orii.xyz/categories/Web/Blog/"/>
    
    
    <category term="Web" scheme="https://blog.orii.xyz/tags/Web/"/>
    
    <category term="Blog" scheme="https://blog.orii.xyz/tags/Blog/"/>
    
  </entry>
  
</feed>
